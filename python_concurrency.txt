Asyncio
=======

functions have a "async" in front and code "await"s for control back.
Start tasks with asyncio.create_task() & wait for them to run in paralle with "await asyncio.wait()".
Same set of tasks can be gathered with "ayncio.gather()" - which can also take coroutines generated by our "async def fn()".
Py 3.11 introduces task group that use context manager with to ensure all tasks are awaited


### Asyncio
import time
import asyncio

async def task_fn(interval, count):
    print("Task started. Count=", count)
    # time.sleep(interval)      # not an async function
    await asyncio.sleep(interval)
    print("Task ended. Count=", count)

async def main():
    sleep_iterval = ['1.25','1.30','1.20']
    start = time.perf_counter()
    # for interval,count in enumerate(sleep_iterval):
    #     await task(interval, count)

    # tasks = [asyncio.create_task(task_fn(interval,count))
    #                             for interval,count in enumerate(sleep_iterval)]

    # done, pending = await asyncio.wait(tasks, timeout=1.25) 	# if timeout not specified then all tasks will be done
    # print("Done tasks:")
    # for tsk in done:
    #     result = tsk.result()		# any exceptions in task would be raised now
    #     print(result)
    # print("Pending tasks:")
    # for tsk in pending:
    #     print(tsk)      # Task has a "wait_for"
    # print(done, pending)

    # tasks = [asyncio.create_task(task_fn(interval,count))
    #                              for interval,count in enumerate(sleep_iterval)]
    # results = await asyncio.gather(*tasks)  # can take co-routines directly which asyncio.await can't do
    
    co_routines = [task_fn(interval,count) for interval,count in enumerate(sleep_iterval)]
    results = await asyncio.gather(*co_routines, return_exceptions=True)	# use try-catch here if not using return_exceptions=True
    print(results)

    end  = time.perf_counter()
    print("All done", end-start)

if __name__ == '__main__':
    asyncio.run(main())
