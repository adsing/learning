class X {
	X();			// constructor default
	~X();			// destructor (make it "virtual" if it will be inherited)

	X(int x);		// user constructor
	
	X(const X &x);		// copy constructor
	X& operator=(const X &x); // copy assignment operator	
	
	X(X &&x);		// move constructor
	X& operator=(X &&x); 	// move assignment operator
	}
# If destructor or if resources are being locked (RAII) is specified then define all the above.	

Map: Key-value ordered pair. Also has unordered_map.

if (obj[key])  	# inserts element key into map obj. Instead use obj.at(key) that is const read-only and will not modify map object


Map with structured binding usage:
for(const auto & [key, value]: map_obj) { cout << key << value << '\n';} # using structured binding 
instead of 
for(const auto & item : map_obj) { cout << item.first << item.second << '\n';} # 


Do not modify container (vector, map etc) while looping over it as it may get resized with insert (or delete) and m.end() may be updated


Base destructor should be virtual so that if a pointer to base class is destroyed, it used v-table to determine it's tru destructor as well.
void complete_base( unique_ptr<BaseClass> ptr) { do something with ptr->fn() and auto delete ptr when out of scope }  # Note ptr is ptr to DerivedClass passed to a fn that expects BaseClass Ptr (interface).


Use override in inherited class to indicate which method is over-ridden to avoid creating a new method with a typo in name.
class Derived: public Base {
   public:
   	~ Derived() override {...}
   	

Class initializer list - initializes elements in the order defined in class definition.


Value initialized vs default (garbase initialized)
Set to garbage:
	int x;
	int *xp = new int;
Set to zero:
	int x {};
	int *xp = new int();
	int *xp = new int{};
	

Constants:
constexpr double PI {3.14159};	# constexpr at compile time vs const at run time


Constant Pointer vs Pointer to constant

const int a = 10;	// or int const a = 10; 		indicates int value is constant
const int* ptr = &a;  	// or int const * ptr = & a;		indicates int value pointed by pointer is constant but pointer can be moved around
*ptr = 5; // wrong
ptr++;    // right


int a = 10;
int *const ptr = &a;  		// ptr (to int) is constant so int value pointed by it can be changed
*ptr = 5; // right
ptr++;    // wrong

std::unique_ptr and std::shared_ptr
std::unique_ptr<UserClassName> ptr;	// cheaper to keep unique ptr that destruct when out of scope. Unique_ptr is better suited for multi-threaded programming
std::shared_ptr<UserClassName> share_ptr = std::move(ptr);	// make unique_ptr into shared_ptr (does ref.counting and destroys when ref.count=0)


Cpp coding guidelines: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
