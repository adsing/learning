Online - https://scastie.scala-lang.org/

ScaLa - scalable lang. (At time of writing March 2019, Scala 2.12 is available)
Functional + OO (everythin is an object)

Every fn is a value
A value an object
and hence, a function an object

Runs on JVM (same run time platform a Java so both can co-exist)

Allows concurrency.
Domain specific language support (DSL)

Closure − A closure is a function, whose return value depends on the value of one or more variables declared outside this function.

Traits − A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Traits are used to define object types by specifying the signature of the supported methods.

Scala - runs in interactive mode or script mode

Interactive:
> println("Hello world!")

Script-mode:
# HelloWorld.scala
object HelloWorld{
  def main(args: Array[String]){
    println("hello")    
  }
}

$ scalac HelloWorld.scala    #gemerates a new class HellowWorld.class
$ scala  HellowWorld

Operators: +, ++, <?>, :::, 
Mixed Identifiers: unary_+ or myvar_= (operator overloading)
Identifier: ok if in `abc`

Semicolon line delimit optional

Packaage:  com.site.packagename
import com.site.packagename
import scala.xml._           //import everything in scala.xml package
import scala.collection.mutable.HashMap
import scala.collection.immutable.{TreeMap, TreeSet}  //import 2 objects


applyDynamic is a trait that enabkes dynamic innvocations for any methods/args.
method/args are re-written:
foo.method(x = "blah") ~~> foo.applyDynamicNamed("method")(("x", "blah"))
foo.method(x = 1, 2) ~~> foo.applyDynamicNamed("method")(("x", 1), ("", 2))
foo.field ~~> foo.selectDynamic("field")
foo.varia = 10 ~~> foo.updateDynamic("varia")(10)
foo.arr(10) = 13 ~~> foo.selectDynamic("arr").update(10, 13)
foo.arr(10) ~~> foo.applyDynamic("arr")(10)

Types: Byte/Short/Long/Int/Float/Double/Char/String/Boolean/Null/Unit(no value)/Any/AnyRef
String in double quotes("...."); char in single quotes.
Multi-line : """...."""

Symbol literal:
'x = scala.Symbol("x")

Variable declaration:
var or val VariableName : DataType = [Initial Value]    //var is variable (mutable) while val is a constant(immutable)
e.g.
val myVal = "Hello, Scala!";   //Type inference; no need to define data type
val (myVar1: Int, myVar2: String) = Pair(40, "Foo")   //tuple


Sample class with main:
#
import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc
   
   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println ("Point x location : " + x);
      println ("Point y location : " + y);
   }
}

object Demo {
   def main(args: Array[String]) {
      val pt = new Point(10, 20);

      // Move to a new location
      pt.move(10, 10);
   }
}
#

Inheritance/Extension of a class:
- use extends key word
- inherit from one class only
Two restrictions: 
1. method overriding requires the "override" keyword, 
2. only the constructor can pass parameters to the base constructor

class Location(override val xc: Int, override val yc: Int, val zc :Int) extends Point(xc, yc){
   var z: Int = zc

   def move(dx: Int, dy: Int, dz: Int) {
      x = x + dx
      y = y + dy
      z = z + dz
      println ("Point x location : " + x);
      println ("Point y location : " + y);
      println ("Point z location : " + z);
   }
}

Implicit class : whose methods can be called as such classes can't be top-level class.
They are defined inside other class/trait/object
They take only one argument
#
object <object name> {
   implicit class <class name>(<Variable>: Data type) {
      def <method>(): Unit =
   }
}

Can not have singleton members; only objects e.g. see example with main.

Access modifier - private, protected, public (default)
Scope protection - limit to this, outer class or outermost class. private[scope] var x = Int 10;
#
package society {
   package professional {
      class Executive {
         private[professional] var workDetails = null
         private[society] var friends = null
         private[this] var secrets = null

         def help(another : Executive) {
            println(another.workDetails)
            println(another.secrets) //ERROR
         }
      }
   }
}
